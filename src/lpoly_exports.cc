/* Software License Agreement (BSD License)
 *
 * Copyright (c) 2014, Ross Linscott (rossklin@gmail.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *     Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *
 *     The names of its contributors may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#if defined(NDEBUG)
#undef NDEBUG
#endif

#include <cstdlib>
#include <cmath>
#include <cstring>

#include <boost/random/mersenne_twister.hpp>
#include <boost/random/normal_distribution.hpp>
#include <boost/random/variate_generator.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

#ifdef STANDALONE
#include <RInside.h>
#endif

#include "../inst/include/SimpleSDESampler.h"

//' LPoly system constructor
//'
//' Returns an XPtr to an lpoly_system_type object
//' @param cm Model coefficient matrix
//' @param trm Model term specification, as generated by lpoly_model_spec (each row represents the powers of the different factors in a term)
//' @export
// [[Rcpp::export]]
XPtr<lpoly_system_type> lpoly_make_system_xptr(NumericMatrix cm, NumericMatrix trm){

  if (cm.ncol() != trm.nrow()){
    Rcpp::Rcout << "lpoly_make_system: dimension mismatch: " << cm.ncol() << " != " << trm.nrow() << endl;
    exit(-1);
  }

  return XPtr<lpoly_system_type>(new lpoly_system_type(lpoly_evaluator(cm,trm), lpoly_jacobian(cm, trm)), true);
}

//' LPoly model matrix generator
//'
//' Builds the model matrix from the data using the lpoly_system_type object
//' @param lps XPtr to an lpoly_system_type object created by a call to lpoly_make_system
//' @param data One column per measurement variable
//' @export
// [[Rcpp::export]]
NumericMatrix lpoly_model_matrix(XPtr<lpoly_system_type> lps, NumericMatrix data){
  return lps -> first.build(data);
}

//' LPoly Jacobian
//'
//' Builds the model matrix from the data using the lpoly_system_type object
//' @param lps XPtr to an lpoly_system_type object created by a call to lpoly_make_system
//' @param state Single row matrix
//' @export
// [[Rcpp::export]]
NumericMatrix lpoly_compute_jacobian(XPtr<lpoly_system_type> lps, NumericMatrix state){
  uvector q(state.ncol());
  umatrix res;
  memcpy(&q(0), &state[0], q.size() * sizeof(double));
  lps -> second(q, res, 0);
  return as_r_matrix(res);
}


//' LPoly System Implicit SDE Simulator using NLOPT
//'
//' Simulates a trajectory to the SDE specified by *sys* and the noise level sigma, starting at the point start and integrating over times [*from*,*to*] on *steps + 1* time points.
//' @param sys lpoly_system_type XPtr object created with lpoly_make_system
//' @param sigma Amplitude of noise: scalar
//' @param start Initial position: n vector
//' @param from Initial time: scalar
//' @param to Final time: scalar
//' @param steps Number of points to take, s.t. dt = (from - to) / (steps + 1): integer
//' @export
// [[Rcpp::export]]
NumericMatrix lpoly_sde(XPtr<lpoly_system_type> sys
			, double sigma
			, NumericVector start
			, double from, double to, int steps 
			, double x_tol = 0
			, const char* algorithm = "LBFGS") {

  const double dt = (to - from)/steps;
  lpoly_system s(sys);
  nlopt_stepper stepper(&s, dt, start.size(), sigma, steps, x_tol, algorithm);

  return lpoly_sde(stepper, start, from, to, steps, x_tol, algorithm);
}


//' LPoly System Implicit SDE Simulator using NLOPT, with precached noise data
//'
//' Simulates a trajectory to the SDE specified by *sys* and the noise level sigma, starting at the point start and integrating over times [*from*,*to*] on *steps + 1* time points.
//' @param sys lpoly_system_type XPtr object created with lpoly_make_system
//' @param noise Noise buffer (brownian motion normalised steps ~N(0,sigma^2))
//' @param start Initial position: n vector
//' @param from Initial time: scalar
//' @param to Final time: scalar
//' @param steps Number of points to take, s.t. dt = (from - to) / (steps + 1): integer
//' @export
// [[Rcpp::export]]
NumericMatrix lpoly_sde_precached(XPtr<lpoly_system_type> sys
				  , NumericMatrix noise
				  , NumericVector start
				  , double from
				  , double to
				  , int steps 
				  , double x_tol = 0
				  , const char* algorithm = "LBFGS") {

  const double dt = (to - from)/steps;
  lpoly_system s(sys);
  nlopt_stepper stepper(&s, dt, start.size(), as_ublas_matrix(noise), x_tol, algorithm);

  return lpoly_sde(stepper, start, from, to, steps, x_tol, algorithm);
}

//' LPoly System Implicit SDE Simulator: time-wise averages
//'
//' Samples multiple times from lpoly_sde and returns the time-wise average
//' @param nrep Number of repetitions to average over: integer
//' @param sys lpoly_system_type XPtr object created with lpoly_make_system
//' @param sigma Amplitude of noise: scalar
//' @param start Initial position: n vector
//' @param from Initial time: scalar
//' @param to Final time: scalar
//' @param steps Number of points to take, s.t. dt = (from - to) / (steps + 1): integer
//' @export
// [[Rcpp::export]]
NumericMatrix lpoly_sde_averages( int nrep
				  , XPtr<lpoly_system_type> sys
				  , double sigma
				  , NumericVector start
				  , double from, double to, int steps){
  
  NumericMatrix result(steps+1, start.size());
  NumericMatrix buf;
  int i,j;
  double *p, *q;
  int smax = result.nrow() * result.ncol();

  p = &result(0,0);

  memset(p, 0, smax * sizeof(double));
  
  for (i = 0; i < nrep; i++){
    buf = lpoly_sde( sys
		     , sigma
		     , start
		     , from
		     , to
		     , steps);

    q = &buf(0,0);
    for (j = 0; j < smax; j++){
      p[j] += q[j];
    }
  }

  for (j = 0; j < smax; j++){
    p[j] /= nrep;
  }

  return result;
} 
